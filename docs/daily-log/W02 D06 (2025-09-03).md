# W02 D06 (2025-09-03)

## ✅ 오늘 한 일
### BE
- **reservation / catalog 서버 분리 및 기동**
  - 왜? → 기존 모놀리식 구조를 MSA 스타일로 전환하기 위해.
  - 그래서 → `reservation` 모듈과 `catalog` 모듈을 분리하고 각 서버(8080, 8081)로 실행되도록 설정.
  - 결과 → 두 서비스가 동시에 구동되고, FE와 연결 가능.

- **CORS 설정 수정**
  - 왜? → FE(5173)에서 API 호출 시 CORS 에러 발생.
  - 그래서 → `CorsConfig`를 각 서비스에 추가하고 경로 프리픽스(`/ticketing/api/**`) 반영.
  - 결과 → 이벤트/좌석 조회 API가 정상적으로 동작.

### FE
- **TanStack Query 적용**
  - 왜? → API 데이터 캐싱 및 상태관리 일원화.
  - 그래서 → `useEvents`, `useEvent`, `useQuery` 등으로 각 API 호출 로직 구성.
  - 결과 → 이벤트 목록, 이벤트 상세, 좌석맵 데이터가 캐시 키(`["events"]`, `["event", id]`, `["seats", eventId]`) 기반으로 관리됨.

- **캐시 키 설계**
  - 왜? → 좌석 선점/해제 시 데이터 일관성을 보장하기 위해.
  - 그래서 → `invalidateQueries(["seats", eventId])`를 통해 해당 이벤트 좌석맵만 새로고침.
  - 결과 → 다른 유저 탭에서도 약 1.5초 간격으로 좌석 상태 동기화 확인.

- **.env 분리**
  - 왜? → catalog(8080), reservation(8081) API 분리 필요.
  - 그래서 → `VITE_CATALOG_API`, `VITE_RESERVATION_API` 환경변수 적용.
  - 결과 → 이벤트 조회는 8080, 예약 관련 API는 8081로 호출 성공.

### Infra/테스트
- **Redis TTL 기반 좌석 동시성 제어 확인**
  - 왜? → 동시에 여러 클라이언트가 같은 좌석을 선점했을 때 일관성 보장 필요.
  - 그래서 → Redis TTL + Lua Script 기반 seat hold 검증.
  - 결과 → 중복 선점 차단 및 만료 자동 반납 동작 확인.

---

## 📚 배운 점
- **TanStack Query 캐시 키 설계**  
  → API별 캐시 키를 계층적으로 나눠야 invalidate 시 원하는 데이터만 갱신 가능.  
- **폴링(refetchInterval)의 의미**  
  → 즉시 반영 대신 1.5초 주기를 둬서 서버 부하와 실시간성을 절충.  

---

## 💡 느낀 점 / 회고
- 모놀리식에서 MSA로 분리하면서도 기능이 동일하게 유지되는 게 중요한 경험이었다.  
- FE/BE를 동시에 고쳐야 하는 부분(CORS, API_BASE)이 꽤 많았고, 작은 설정 차이로도 큰 장애가 생길 수 있음을 배움.  
- TanStack Query 캐시 키를 통해 데이터 흐름이 더 명확히 관리된다는 걸 체감했다.  

---

## 📊 검증 결과 (DoD)
- 이벤트/좌석 조회 정상 동작 ✅  
- 좌석 클릭 → 장바구니 추가 → 연장/제거 → 결제(모의) 플로우 정상 ✅  
- FE와 BE(8080, 8081) API 연동 성공 ✅  
- Redis TTL 기반 동시성 제어 OK ✅  

---

## 📸 결과물 캡처
- BE 구조(root : ticketing): ![결과 스크린샷](./images/W02 D06 BE structure.png)  