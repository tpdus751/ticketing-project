# W02 D07 (2025-09-05)

## ✅ 오늘 한 일

### BE
- **Order 모듈 Outbox 패턴 연결**
  - 왜? → 주문 생성 시 바로 DB에 반영하지 않고, Outbox 테이블을 통해 Kafka로 비동기 전송/재시도 가능하게 하기 위함.
  - 그래서 → `OutboxEvent`, `OutboxWorker` 구현 후 `@EnableScheduling`으로 5초마다 `PENDING` 상태 이벤트를 Kafka로 발행하도록 함.
  - 결과 → Outbox에 `ORDER_CREATED` 이벤트가 쌓이고, 정상 발행 시 `SENT`, 실패 시 `FAILED`로 상태 전환되는 것 확인.

- **Idempotency 보장**
  - 왜? → 동일한 요청이 중복 전송되어도 주문이 여러 번 생성되는 것을 방지해야 하기 때문.
  - 그래서 → `orders.idempotency_key` 컬럼에 `unique = true` 제약 추가. `OrderService`에서 `Idempotency-Key` 헤더 기반 중복 방지 처리.
  - 결과 → 같은 키로 두 번 요청 시 DB ConstraintViolationException 발생, 멱등성 보장 확인.

- **좌석 다건 주문 지원**
  - 왜? → 실제 시나리오에서는 여러 좌석을 동시에 결제해야 하므로 단일 좌석 주문만 지원하는 구조를 개선해야 했음.
  - 그래서 → `seat_ids` 컬럼을 JSON 배열로 저장하도록 수정, `OrderService`에서 `ObjectMapper` 기반 직렬화/역직렬화 처리.
  - 결과 → 여러 좌석 선택 후 주문 가능, Outbox에도 seatIds 배열이 올바르게 저장됨.

- **Reservation ↔ Catalog 연동 안정화**
  - 왜? → 예약 확장(`extendHold`) 및 해제(`releaseHold`) 시 좌석 상태 변경이 Catalog 구독자들에게 실시간 반영되어야 함.
  - 그래서 → `CatalogNotifier`를 통해 `/internal/seat-update` 호출 → `EventStreamController`에서 `publishSeatChange` 수행.
  - 결과 → 예약/해제 시 즉시 HELD ↔ AVAILABLE 상태로 반영되는 것 확인.

- **SSE 안정화**
  - 왜? → 다중 브라우저 구독 상황에서 `ResponseBodyEmitter has already completed` 오류가 발생.
  - 그래서 → `EventStreamController`에 `historyByEvent` 큐 추가, `Last-Event-ID` 기반 재전송 처리 구현.
  - 결과 → 브라우저 두 개에서 동시에 접속 후 한 쪽이 예약하면 다른 브라우저에도 실시간 반영됨. 오류 사라짐.

---

### FE
- **주문 API 연동**
  - 왜? → 기존에는 Reservation 모듈이 좌석 SOLD까지 처리했으나, Order 모듈로 분리됨.
  - 그래서 → `CartDrawer`의 checkout 로직을 `orderApi.post("/api/orders")`로 수정, `Idempotency-Key` 헤더 추가.
  - 결과 → 주문 시 Order 모듈에 요청이 전송되고, Outbox 이벤트 생성까지 정상 작동.

- **SSE 클라이언트 개선**
  - 왜? → 기본 `EventSource` 사용 시 재연결/이벤트 유실 처리가 부족했음.
  - 그래서 → `sse.ts`에서 Fetch 기반 스트리밍 파서 작성, `Last-Event-ID` 지원 및 재연결 로직 추가.
  - 결과 → 탭 2개 이상에서 좌석 상태 동기화 안정화, 누락된 이벤트도 재전송되어 반영됨.

---

### Infra/테스트
- **부하 테스트(k6)로 100석 쟁탈전 시뮬레이션**
  - 왜? → 동시성 하에서 좌석 선점 충돌 비율과 성능을 검증하기 위함.
  - 그래서 → 이벤트 3번의 좌석 번호 리스트(100석)를 무작위로 선택하는 k6 스크립트 작성. 200 VU, 10s 동안 시뮬레이션 수행.
  - 결과 →  
    - 201 Created (성공): 약 5%  
    - 409 Conflict (이미 선점됨): 약 95%  
    - 평균 응답속도: ~56ms  
    - 동시성 충돌 방어 및 성능 모두 정상 동작.

---

## 📚 배운 점
- **Idempotency-Key 기반 멱등성 보장**
  - 분산 환경에서 중복 요청은 필연적 → 키 기반 제약이 필수.
- **SSE Last-Event-ID**
  - 끊겼다가 재연결 시 누락된 이벤트를 재전송해주어야 실시간성 보장 가능.
- **Outbox 패턴**
  - Kafka 발행 실패 시에도 DB 내 이벤트 상태를 기반으로 재처리 가능 → 데이터 정합성 유지 핵심.

---

## 💡 느낀 점 / 회고
- 작은 버그(`ResponseBodyEmitter completed`) 하나가 FE 전반의 신뢰성에 영향을 크게 줌을 실감.
- Reservation/Order/Catalog 모듈 간 연동 플로우를 직접 확인하며, “서비스 간 계약”의 중요성을 체감.
- FE와 BE 모두에서 “실패를 예상하고 복구하는 코드”가 필요함을 배움.

---

## 📊 검증 결과 (DoD)
- Order Outbox → Kafka 발행/재시도 정상 동작.
- Idempotency 보장 확인 완료.
- 다좌석 주문 및 실시간 반영 정상.
- k6 부하테스트 성공 → 200 VU, 10초간 동시 요청 시 충돌 비율 및 성능 정상.
- DoD 충족.

---

## 📸 결과물 캡처
- <video src="../videos/W02 D07 order_outbox_pending_to_sent.mp4" controls width="800">
  Outbox 상태 전환 로그 영상
</video>
- <video src="../videos/W02 D07 two brower test.mp4" controls width="800">
  브라우저 2개 동시 접속 시 좌석 HELD 실시간 반영 화면  
</video>
- <img src="../images/W02 D07 k6 result 100vu 10s.png">k6 부하 테스트 결과 리포트</img>  
