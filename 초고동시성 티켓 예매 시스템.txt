초고동시성 티켓 예매 시스템

pnpm : Performant NPM 의 약자로, NodeJS 환경에서 사용되는 고성능 패키지 매니저 (기존의 npm , yarn 과 동일한 목적을 가지지만, 저장 공간 절약과 빠른 설치 속도가 특징)

pnpm dlx : Node.js 프로젝트에서 특정 패키지를 의존성으로 설치하지 않고 임시로 가져와서 실행하는 명령어

Flyway : 데이터베이스을 마이그레이션 할 수 있는 툴

Record Class(JAVA) : 불변(immutable) 객체를 쉽게 생성할 수 있도록 하는 유형의 클래스, final 클래스(상속불가)

MDC(Mapped Diagnostic Context) : 
- 로깅 코드에서 특정 데이터를 쉽게 사용할 수 있도록 하는 메커니즘
- 한 스레드에서 실행되는 작업 간에 로깅 코드를 통해 데이터를 전파할 수 있음
- 스프링부트에서 MDC는 주로 로깅 프레임워크에서 제공하는 기능을 활용하며 주로 SLF4J와 함께 사용됨
- MDC를 사용하면 로그 메시지에 특정 컨텍스트 정보를 쉽게 추가할 수 있음

Redis : Key, Value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터 베이스 관리 시스템 (DBMS), 데이터베이스, 캐시, 메세지 브로커로 사용되며 인메모리 데이터 구조를 가진 저장소
- 사용자가 늘어난다면 데이터 베이스가 과부하 될 수 있기 때문에 이때 캐시 서버를 도입하여 사용
- 캐시 : 한번 읽어온 데이터를 임의의 공간에 저장하여 다음에 읽을 때는 빠르게 결괏값을 받을 수 있도록 도와주는 공간
- Redis 사용에 주의할 점
-- 서버에 장애가 발생했을 경우 그에 대한 운영 플랜이 꼭 필요 -> 인메모리 데이터 저장소의 특성상, 서버에 장애가 발생했을 경우 데이터 유실이 발생할 수 있기 때문
-- 메모리 관리가 중요
-- 싱글 스레드의 특성상, 한 번에 하나의 명령만 처리할 수 있습니다. 처리하는데 시간이 오래 걸리는 요청, 명령은 피해야 합니다.
- TTL 특성
-- Redis는 지정된 시간이 지나면 키가 자동으로 삭제되는 TTL 기능을 제공
-- 현재 컴퓨터 시간을 기반으로 TTL이 동작

메트릭(Metric) : 시간이 지남에 따라 변화하는 데이터를 의미, 메모리 사용률, CPU 사용률, 스레드 사용률 등등.. 시간에 따른 추이를 추적할 가치가 있는 데이터
- SpringBoot는 Metric 수집을 마이크로미터(MicroMeter) 모듈을 내장한 엑츄에이터가 담당

프로메테우스(Prometheus) : 메트릭 전용 외부 DB -> 메트릭은 시간이 흐를수록 계속 쌓이게 된다. Application의 메모리만으로는 증가하는 메트릭 데이터를 모두 커버할 수 없다
- 프로메테우스는 마이크로미터가 수집한 메트릭 데이터를 일정시간 간격으로 PULL하여 DB에 수집 -> MicroMeter Prometheus 구현체가 필요 (마이크로미터는 수집한 메트릭을 JSON 방식으로 전달하지만 프로메테우스는 JSON 데이터를 처리하지 못한다. 그래서 마이크로미터와 프로메테우스 사이에는 JSON 데이터를  프로메테우스가 처리가능한 데이터 형식으로 변환하는 구현체가 필요)

SSE : Server-Sent-Event의 약자로, 서버에서 클라이언트로 실시간 이벤트를 전달하는 웹 기술.
- 단방향 통신

SAGA 패턴 : 마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크로서비스들에게 보상 이벤트를 소싱함으로써 분산 환경에서 원자성을 보장하는 패턴
- 핵심 : 트랜잭션의 관리주체가 DBMS에 있는 것이 아닌 Application에 있음.
- 패턴
-- Choreography based SAGA pattern : 보유한 서비스내의 Local 트랜잭션을 관리하며 트랜잭션이 종료하게 되면 완료 Event를 발행합니다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 App으로 이벤트를 보내고, 해당 App은 완료 Event를 수신받고 다음 작업을 진행(이를 순차적으로) 이때 Event는 Kafka와 같은 메시징 큐를 통해 비동기 방식으로 전달
--- 각 App별로 트랜잭션을 관리하는 로직이 있는데, 이를 통해서 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도
--- 장점 : 구성하기 편함
--- 단점 : 운영자 입장에서 트랜잭션의 현재 상태를 확인하기 어려움
-- Orchestration based SAGA pattern  : 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재. 트랜잭션에 관여하는 모든 App은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고,
비즈니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해 전체 트랜잭션을 종료. 만약 중간에 실패하게 되면 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지.
--- 모든 관리를 Manager가 호출하기 때문에 분산트랜잭션의 중앙 집중화가 이루어짐
--- 장점 : 서비스간의 복장성이 줄어들어서 구현 및 테스트가 쉬워짐, 트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백을 하기 쉬움.
--- 단점 : 관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해짐 

MSA 환경에서의 분산 로그 트레이싱
- OpenTracing : 애플리케이션 간에 분산된 호출 흐름을 공개적으로 추적하기 위한 표준 (표준을 기준으로 여러 Tracer(Zipkin, Jaeger)등이 존재
- 분산 로그 추적 시스템 작동원리
-- Trace : 클라이언트가 서버로 호출한 하나의 흐름
-- Span : 서비스 컴포넌트간의 호출
-- 각 서비스 컴포넌트들은 하나의 클라이언트 호출을 추적하기 위해서 같은 Trace Id를 사용하고, 각 서비스 간의 호출은 각각 다른 Span Id를 사용 -> 전체 트랜잭션 시간을 Trace로 추적이 가능하고, 각 서비스별 구간 시간은 Span으로 추적 가능

리버스 프록시 : 클라이언트 요청을 대신 받아 내부 서버로 전달해주는 것
- 프록시 : 대리, 정보를 대신 전달해주는 주체
- 장점 
-- 로드밸런싱 : Nginx는 클라이언트의 요청을 프록시 서버에 분산하기 위해 로드 밸런싱을 수행하여 성능, 확장성 및 신뢰성을 향상시킬 수 있습니다.
-- 캐싱 : Nginx를 역방향 프록시로 사용하면 미리 렌더링딘 버전의 페이지를 캐시하여 페이지 로드 시간을 단축할 수 있음. 이 기능은 프록시 서버의 응답에서 수신한 콘텐츠를 캐싱하고 이 콘텐츠를 사용하여 매번 동일한 콘텐츠를 프록시 서버에 연결할 필요 없이 클라이언트에 응답
-- SSL 터미네이션 : Nginx는 클라이언트와의 연결에 대한 SSL 끝점 역할을 할 수 있습니다. 수신 SSL 연결을 철 ㅣ밒 해독하고 프록시 서버의 응답을 암호화
-- 압축 : 프록시 서버가 압축된 응답을 보내지 않는 경우 클라이언트로 보내기 전에 응답을 압축하도록 Nginx를 구성할 수 있음
-- DDos 공격 완화
